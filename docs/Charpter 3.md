# 深入理解操作系统 第三章 计算机体系结构及内存分层体系  

>   第三章的主要内容是：操作系统的物理内存管理

## 计算机体系结构

1.  CPU
2.  内存
3.  I/O
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/602a969b-e801-43ac-bf74-31046eff640a)


## 内存分层体系
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/af3ff3c3-4ebf-4b32-b757-512ca4c35a88)

寄存器 / cache(L1缓存 / L2缓存)：两者是位于CPU芯片内部的，操作系统无法直接进行管理，但是它的速度很快，容量较小
主存：物理内存（用来存放操作系统本身和运行的程序）
硬盘（虚拟内存）：

### 内存分层体系

运行内存(主存) / 磁盘(虚拟内存). 主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间.

CPU可以访问的内存包括两大类 : 寄存器 / cache(L1缓存 / L2缓存)

**层次**

微处理器

|___CPU寄存器 / L1缓存

|___L2缓存

主存

磁盘

>   从CPU寄存器到磁盘，读写速度不断降低，单位成本不断降低，大小不断增大。

### 操作系统在内存管理方面需要完成的目标

*   抽象：逻辑地址空间

*   保护：独立地址空间（内存中运行多个不同的应用程序，相互之间可能访问别的进程的地址空间，也可能破坏别的进程的地址空间，需要有效的机制保护进程之间的地址空间是需要隔离的，这种隔离机制的实现也是由操作系统实现的）

*   共享：访问相同内存（进程之间可能需要进行交互，专门提供这种共享的空间，来使得进程之间能够安全可靠的进行数据的传递，这也是靠操作系统的机制完成的）

*   虚拟：更多的地址空间（也就是虚拟内存）
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/1c744b37-8cfb-4161-9cac-b59e0fa7faae)


### 内存管理方法

*   程序重定位
*   分段
*   分页
*   虚拟内存
*   按需分页虚拟内存

>   实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求

## 地址空间

地址空间的定义

*   物理地址空间 —— 硬件支持的地址空间( address : [0, Max_sys] )
*   逻辑地址空间 —— 一个运行在程序所拥有的的内存范围( address : [0, Max_prog] )

## 连续内存分配

### 内存碎片问题

内存碎片问题指的是空闲的内存无法被利用

*   外部碎片 : 分配单元间的未使用内存
*   内部碎片 : 分配单元内的未使用内存

### 分区的动态分配

分区的动态分配方式有以下三种 :

1.  第一匹配分配 : 在内存中找到第一个比需求大的空闲块, 分配给应用程序
2.  最优适配分配 : 在内存中找到最小的空闲块, 分配给应用程序
3.  最差适配分配 : 在内存中找到最大的空闲块, 分配给应用程序

分配方式的区别

| 分配方式         | 第一匹配分配                                                 | 最优适配分配                                                 | 最差适配分配                                                 |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 分配方式实现需求 | 1. 按地址排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 | 1. 按尺寸排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 | 1. 按尺寸排序的空闲块列表<br />2. 分配最大的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 |
| 优势             | 简单 / 易于产生更大空闲块                                    | 比较简单 / 大部分分配是小尺寸时高效                          | 分配很快 / 大部分分配是中尺寸时高效                          |
| 劣势             | 产生外部碎片 / 不确定性                                      | 产生外部碎片 / 重分配慢 / 产生很多没用的微小碎片             | 产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配 |

>   三种分配方式并无优劣之分，因为我们无法判断内存请求的大小

## 碎片整理方法

可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。

1.  压缩式碎片整理
    *   重置程序以合并碎片
    *   要求所有程序是动态可重置的
    *   问题 : 
        *   何时重置 ? (在程序处于等待状态时才可以重置)
        *   需要考虑内存拷贝的开销

2.  交换式碎片整理

    *   运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存

    *   问题 :

        *   哪些程序应该被回收 ?

    *   情况 :

        运行中 : P3

        等待中 : P1 P2 P4

        内存分布 -> 主存 : OS / P1 / P3 / P2 / P4 磁盘 : 空

        当P3程序需要更大的内存时 ->

        内存分布 -> 主存 : OS / P1 / P3 / P2         磁盘 : P4



