# 深入理解操作系统 第三章 计算机体系结构及内存分层体系  

>   第三章的主要内容是：操作系统的物理内存管理

## 计算机体系结构

1.  CPU
2.  内存
3.  I/O
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/602a969b-e801-43ac-bf74-31046eff640a)


## 内存分层体系
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/af3ff3c3-4ebf-4b32-b757-512ca4c35a88)

寄存器 / cache(L1缓存 / L2缓存)：两者是位于CPU芯片内部的，操作系统无法直接进行管理，但是它的速度很快，容量较小
主存：物理内存（用来存放操作系统本身和运行的程序）
硬盘（虚拟内存）：

### 内存分层体系

运行内存(主存) / 磁盘(虚拟内存). 主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间.

CPU可以访问的内存包括两大类 : 寄存器 / cache(L1缓存 / L2缓存)

**层次**

微处理器

|___CPU寄存器 / L1缓存

|___L2缓存

主存

磁盘

>   从CPU寄存器到磁盘，读写速度不断降低，单位成本不断降低，大小不断增大。

### 操作系统在内存管理方面需要完成的目标

*   抽象：逻辑地址空间

*   保护：独立地址空间（内存中运行多个不同的应用程序，相互之间可能访问别的进程的地址空间，也可能破坏别的进程的地址空间，需要有效的机制保护进程之间的地址空间是需要隔离的，这种隔离机制的实现也是由操作系统实现的）

*   共享：访问相同内存（进程之间可能需要进行交互，专门提供这种共享的空间，来使得进程之间能够安全可靠的进行数据的传递，这也是靠操作系统的机制完成的）

*   虚拟：更多的地址空间（也就是虚拟内存）
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/1c744b37-8cfb-4161-9cac-b59e0fa7faae)


### 内存管理方法

*   程序重定位
*   分段
*   分页
*   虚拟内存
*   按需分页虚拟内存

>   实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求
MMU是Memory Management Unit的缩写，中文名是内存管理单元，有时称作分页内存管理单元（英语：paged memory management unit，缩写为PMMU）。它是一种负责处理中央处理器（CPU）的内存访问请求的计算机硬件。它的功能包括虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护、中央处理器高速缓存的控制，在较为简单的计算机体系结构中，负责总线的仲裁以及存储体切换（bank switching，尤其是在8位的系统上） 

## 地址空间&地址生成
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/c433082e-0450-4fe3-81cc-7ad01c83edc8)


### 地址空间的定义

*   物理地址空间 —— 硬件支持的地址空间（和硬件之间对应，包括内存和硬盘，物理地址空间的管理和控制是由硬件完成的）( address : [0, Max_sys] )
*   逻辑地址空间 —— 一个运行在程序所拥有的的内存范围( address : [0, Max_prog] )

![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/9c329ef6-b2b5-42ea-ad7e-9da12e30a89e)
上图中C程序（.c文件，逻辑地址为变量符号名)通过编译形成汇编程序（.s文件，逻辑地址为变量符号名），汇编程序通过汇编形成机器语言程序（.o文件，它的特点时起始地址都是从零开始的，此时变量的符号名和函数的符号名转变成以零开始的相应的逻辑地址），多个机器语言程序（包括库）通过链接形成一个单一的可执行程序（.exe文件，可以在内存中执行的，目前还存放在硬盘中的程序），放在硬盘中的可执行程序通过loader（也是一个应用程序）加载到内存中去运行（此时仍然是逻辑地址）。



### 地址生成
### 地址安全检查

## 连续内存分配

### 内存碎片问题

内存碎片问题指的是空闲的内存无法被利用

*   外部碎片 : 分配单元间的未使用内存
*   内部碎片 : 分配单元内的未使用内存

### 分区的动态分配

分区的动态分配方式有以下三种 :

1.  第一匹配分配 : 在内存中找到第一个比需求大的空闲块, 分配给应用程序
2.  最优适配分配 : 在内存中找到最小的空闲块, 分配给应用程序
3.  最差适配分配 : 在内存中找到最大的空闲块, 分配给应用程序

分配方式的区别

| 分配方式         | 第一匹配分配                                                 | 最优适配分配                                                 | 最差适配分配                                                 |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 分配方式实现需求 | 1. 按地址排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 | 1. 按尺寸排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 | 1. 按尺寸排序的空闲块列表<br />2. 分配最大的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 |
| 优势             | 简单 / 易于产生更大空闲块                                    | 比较简单 / 大部分分配是小尺寸时高效                          | 分配很快 / 大部分分配是中尺寸时高效                          |
| 劣势             | 产生外部碎片 / 不确定性                                      | 产生外部碎片 / 重分配慢 / 产生很多没用的微小碎片             | 产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配 |

>   三种分配方式并无优劣之分，因为我们无法判断内存请求的大小

## 碎片整理方法

可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。

1.  压缩式碎片整理
    *   重置程序以合并碎片
    *   要求所有程序是动态可重置的
    *   问题 : 
        *   何时重置 ? (在程序处于等待状态时才可以重置)
        *   需要考虑内存拷贝的开销

2.  交换式碎片整理

    *   运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存

    *   问题 :

        *   哪些程序应该被回收 ?

    *   情况 :

        运行中 : P3

        等待中 : P1 P2 P4

        内存分布 -> 主存 : OS / P1 / P3 / P2 / P4 磁盘 : 空

        当P3程序需要更大的内存时 ->

        内存分布 -> 主存 : OS / P1 / P3 / P2         磁盘 : P4



