 # 深入理解操作系统 第二章

>   第二章的主要内容是 : 操作系统的异常/中断/系统调用

## 计算机探究计算机启动过程

**作用解析**
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/83277e53-4071-47f8-99a7-c53b12a28d1d)


Disk（硬盘） : 存放OS和Bootloader
Bootloader : 加载OS，将OS放入内存

BIOS （basic I/O system--存放再内存中）: 基于I/O处理系统（一按电源，计算机系统开始检测各种外设）
1.POST（加电自检）（检查自身各种各样设备是否能正常工作） 
2.寻找显卡和执行BIOS
3.把bootloader放到内存中去



![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/755a41e2-eae6-4cfc-a2d3-f4f20d07147a)

![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/256004ed-ed69-4037-8591-548092177fda)




**结构**

Disk

   |___ OS

   |___ Bootloader

**开机流程（以x86为例）**

1.  BIOS
    *   开机后，寻找显卡和执行BIOS (此时, `CS : IP = 0xF000 : 0xFFF0`,  CS/IP 两个寄存器) 
    *   将Bootloader（一般放在硬盘的第一个主引导扇区）从磁盘的引导扇区加载到0x7C00 (Bootloader一共占用512 字节的内存)
    *   cpu指针跳转到 `CS : IP = 0x0000 : 0x7C00`（此时cpu的控制权就由bootloader来掌控了）
    *   找到硬盘上os的起始扇区和os的长度
2.  Bootloader
    *   将操作系统的代码和数据从硬盘加载到内存中
    *   cpu指针跳转到操作系统的起始地址（此时cpu就由os控制了）
    *   这样os就可以再内存中进行必要的工作，从前期的初始化工作，到后期的应用创建和运行，此时整个硬件系统管理就已经处于操作系统的管 理之下了
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/add69e20-5c44-4bb2-b7cc-d4a897adcb20)



## 当操作系统正常工作以后，如何与我们的外设和应用程序打交道
有个interface的设计问题，面向外设是通过中断和I/O来处理，面向应用程序是使用系统调用和异常来提供相应的功能

## 中断、异常、系统调用
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/196965a7-3893-4fe5-a7c5-6b69b01b1dde)


### 中断

中断来源于外设，来自不同的硬件设备的计时器和网络的中断。（处理时间：异步——当事件产生的时候，应用程序不知道什么时候会产生）


**中断流程**

硬件：设置中断标记（CPU初始化）

1.  将内部、外部事件设置中断标记
2.  中断事件的ID

软件

1.  保存中断现场（寄存器之类的一些数据）
2.  根据中断事件的ID跳转到中断服务程序，中断服务程序处理
3.  清楚中断标记
4.  恢复现场

### 异常

异常来源于不良的应用程序，非法指令或者其他坏的处理状态（如：内存出错）。处理时间：同步
响应：杀死或者重新执行意想不到的应用程序指令

**异常处理流程**

1.  保存现场
2.  异常处理
    1.  杀死了产生异常的程序
    2.  重新执行异常指令
3.  恢复现场

### 系统调用

系统调用来源于应用程序，应用程序主动向操作系统发出服务请求（需要一个接口，叫做系统调用接口）。程序访问主要是通过高层次的API，而不是直接调用系统调用。处理时间：异步（例如当程序1发出系统调用读的命令，操作系统转去执行其他程序2，当系统调用返回时，就是异步的）或同步

**APIs**

-   Win32 API 用于Windows
-   POSIX API 用于 POSIX-based systems（包括UNIX，LINUX，Mac OS X）
-   Java API 用于JAVA虚拟机（本质上并不是系统调用API最终还是要通过Wen32 API或POSIX API来实现）

**特点**

-   通常情况下，每个系统调用有对应的序号
    -   系统调用接口根据这些序号来维护表的索引
-   系统调用接口调用内核态中预期的系统调用
    -   并返回系统调用的状态和其他任何返回值
-   用户不需要知道系统调用是如何实现的
    -   只需要获取API和了解操作系统将什么作为返回结果
    -   操作系统接口的细节大部分都隐藏在API中

**用户态**：应用程序运行中，CPU处于的一种特权级的状态，特权级别较低，不能直接访问特殊的机器指令和I/O

**内核态**：操作系统运行中，CPU处于的一种状态，操作系统可以执行任何一条指令，包括特权指令和I/O指令

**系统调用**：触发CPU从用户态到内核态的转换，切换程序和内核的堆栈，需要一定的开销
系统调用和函数调用的区别：
1.当应用程序发出函数调用时，是在一个栈空间完成了函数之间参数的传递和参数返回，当应用程序发出系统调用时，应用程序和和内核拥有各自的堆栈，也就意味着当应用程序发出系统调用以后切换到内核去执行，此时也会切换堆栈， 同时也会完成特权级的转换，由内核态到用户态的转换，堆栈的转换和特权级的转换都会有相应的系统开销，这个开销比函数调用的开销更大，但是相对来说系统调用会比函数调用更安全。**当应用程序执行时，CPU控制权在应用程序，应用程序执行系统调用时，CPU控制权交给操作系统，CPU特权级从用户态改成内核态，系统调用结束后，CPU控制权放回应用程序，CPU特权级反转（要注意CPU控制权的问题——操作系统和应用程序轮流控制CPU，只不过相应的CPU特权级不同，注意不是只有操作系统控制CPU）**

**跨越操作系统边界的开销（值得的且必须的，保证了操作系统的安全性）**
操作系统与应用程序和硬件的交互过程，其实是跨越了操作系统的边界。系统调用，异常和中断时跨越了操作系统和应用程序，操作系统和硬件的边界，跨越边界可以让系统安全可靠正常的运行，但是有一定的代价：
-   在执行时间上的开销超过程序调用
-   开销：
    -   建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销
    -   建立内核堆栈（退出操作系统到应用程序中来执行，需要保存内核堆栈，退出应用程序到操作系统中来，需要保存应用程序堆栈，以及相应的恢复堆栈）
    -   验证参数（操作系统不信任应用程序，怀疑由恶意行为，内核再收到应用程序系统调用以后，会验证发送过来的参数）
    -   内核态映射到用户态的地址空间（更新页面映射权限）（内核处理完数据以后，需要将数据从内核拷贝到应用程序中）
    -   内核态独立地址空间（TLB）

### 区别

| 类型     | 源头                     | 处理时间   | 响应                 |
| -------- | ------------------------ | ---------- | -------------------- |
| 中断     | 外设                     | 异步       | 持续，对应用程序透明 |
| 异常     | 应用程序意向不到的行为   | 同步       | 杀死或重新执行指令   |
| 系统调用 | 应用程序请求系统提供服务 | 同步或异步 | 等待和持续           |

>   异步：应用程序不知道什么时候会发生中断

>   同步：执行到某一条指令一定会发生该事件

### 为什么应用程序不能直接访问硬件？

-   在计算机运行时，内核是被信任的第三方
-   只有内核可以执行特权指令
-   为了方便应用程序（可以让应用程序不必过度注意硬件的细节）

