# 深入理解操作系统 第三章 计算机体系结构及内存分层体系  

>   第三章的主要内容是：操作系统的物理内存管理

## 计算机体系结构

1.  CPU
2.  内存
3.  I/O
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/602a969b-e801-43ac-bf74-31046eff640a)


## 内存分层体系
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/af3ff3c3-4ebf-4b32-b757-512ca4c35a88)

寄存器 / cache(L1缓存 / L2缓存)：两者是位于CPU芯片内部的，操作系统无法直接进行管理，但是它的速度很快，容量较小
主存：物理内存（用来存放操作系统本身和运行的程序）
硬盘（虚拟内存）：

### 内存分层体系

运行内存(主存) / 磁盘(虚拟内存). 主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间.

CPU可以访问的内存包括两大类 : 寄存器 / cache(L1缓存 / L2缓存)

**层次**

微处理器

|___CPU寄存器 / L1缓存

|___L2缓存

主存

磁盘

>   从CPU寄存器到磁盘，读写速度不断降低，单位成本不断降低，大小不断增大。

### 操作系统在内存管理方面需要完成的目标

*   抽象：逻辑地址空间

*   保护：独立地址空间（内存中运行多个不同的应用程序，相互之间可能访问别的进程的地址空间，也可能破坏别的进程的地址空间，需要有效的机制保护进程之间的地址空间是需要隔离的，这种隔离机制的实现也是由操作系统实现的）

*   共享：访问相同内存（进程之间可能需要进行交互，专门提供这种共享的空间，来使得进程之间能够安全可靠的进行数据的传递，这也是靠操作系统的机制完成的）

*   虚拟：更多的地址空间（也就是虚拟内存）
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/1c744b37-8cfb-4161-9cac-b59e0fa7faae)


### 内存管理方法

*   程序重定位
*   分段
*   分页
*   虚拟内存
*   按需分页虚拟内存

>   实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求
MMU是Memory Management Unit的缩写，中文名是内存管理单元，有时称作分页内存管理单元（英语：paged memory management unit，缩写为PMMU）。它是一种负责处理中央处理器（CPU）的内存访问请求的计算机硬件。它的功能包括虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护、中央处理器高速缓存的控制，在较为简单的计算机体系结构中，负责总线的仲裁以及存储体切换（bank switching，尤其是在8位的系统上） 

## 地址空间&地址生成
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/c433082e-0450-4fe3-81cc-7ad01c83edc8)


### 地址空间的定义

*   物理地址空间 —— 硬件支持的地址空间（和硬件之间对应，包括内存和硬盘，物理地址空间的管理和控制是由硬件完成的）( address : [0, Max_sys] )
*   逻辑地址空间 —— 一个运行在程序所拥有的的内存范围( address : [0, Max_prog] )

![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/9c329ef6-b2b5-42ea-ad7e-9da12e30a89e)

上图中C程序（.c文件，逻辑地址为变量符号名)通过编译形成汇编程序（.s文件，逻辑地址为变量符号名），汇编程序通过汇编形成机器语言程序（.o文件，它的特点时起始地址都是从零开始的，此时变量的符号名和函数的符号名转变成以零开始的相应的逻辑地址），多个机器语言程序（包括库）通过链接形成一个单一的可执行程序（.exe文件，可以在内存中执行的，目前还存放在硬盘中的程序），放在硬盘中的可执行程序通过loader（也是一个应用程序）加载到内存中去运行（此时仍然是逻辑地址）。**也就是，在程序员编写应用程序（和汇编程序，也就汇编程序汇编形成的机器语言程序）中的地址都是逻辑地址，当具体访问逻辑地址中存放的内容时，应用程序通过系统调用，由操作系统将逻辑地址转化为物理地址，然后由操作系统去访问对应物理地址存放的内容，然后放回给应用程序**
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/16a1e077-52c5-4c84-9474-aaf291b4cdec)

**（清华向勇老师）start**：物理地址在存储单元角度来讲是唯一的，这种唯一对于写程序来讲是不方便的，因为具体使用哪个地址，程序在写成之前或运行之前是不确定的。因此需要使用逻辑地址，逻辑地址是运行在CPU中的进程看到的地址空间，对应的是可执行文件里的那一段区域。加载程序的时候，程序加载到内存中变成进程，这个时候在可执行文件里的0到最大地址

![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/00df8644-0b2e-4552-b864-a45393c51d6e)
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/c4018a07-988d-4369-90fb-4b8f1cb9ee5d)

上图中，程序加载重定位以后，程序中的地址就变成实实在在的物理地址了，这是生成物理地址的一种方式。生成地址的方式主要有以下几种：

![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/eed8303c-d544-4920-a2d8-69a13c6e4bb0)


上图中的第一种情况————编译时生成物理地址的方式一般在那种老式的功能手机里应用，这种手机的软件是出厂前已经写死的，没法安装新的程序，所以可以在编译时直接生成物理地址。第二种情况就是现在的智能手机，编译时不知道这个应用程序会加载到内存中什么地方，编译时生成的是需要重定位的代码，加载时需要做重定位，根据加载的位置不同需要把程序里的符号代表的逻辑地址重新捋一遍，通常在可执行文件的开头包含了重定位表（里面包含了那些地方的逻辑地址需要改成物理地址），加载的时候全部改成物理地址，程序就可以跑起来了。第三种情况是执行时生成，也就是说在之执行之前一直使用的相对地址，等执行到这条指令的时候，才可以确切知道它访问的是什么地方（而页表中记录着逻辑地址和物理地址之间的对应关系，加载新的页表等时候可以用到，这也是为什么每个进程都有对应的页表），这种情况出现在使用虚拟存储的系统里。第三种情况以为着程序在运行期间可以在内存和硬盘种挪动，以实现虚拟内存技术，而前面两种情况不仅要求应用程序在内存中是连续的，同时运行起来以后，在程序中是不能动的。显然第三种情况是最灵活的。

![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/49c19fc0-f20d-4e61-8464-97f920c1e770)
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/eef787d8-cfc5-4249-be7d-ba64441d5373)

 
**（清华向勇老师）end**



### 地址生成
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/fdf5a7bc-20da-419b-9633-911eddff9bc4)

上图为，逻辑地址到物理地址的转换过程。逻辑地址到物理地址的映射关系是由操作系统建立的，内存管理单元（MMU）更多的是在存贮由操作系统建立的映射关系，

### 地址安全检查
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/ff6914fd-32be-4a0b-b8cf-53e20677d408)

另一方面，操作系统的很重要的一个作用是要确保放到内存中的程序相互之间不能都相互干扰，为此需要确保每一个程序访问的地址空间是合法的，或者说是限制在它的约束范围之内的，限制和约束也是靠操作系统完成的。操作系统需要确保每一个程序有效访问的地址空间（起始地址和长度），一片地址空间为一个程序所用，不能超出，操作系统方面设置每个逻辑地址空间的基址和界限，类似一个由操作系统建立和维护的一个表。

## 连续内存分配

### 内存碎片问题
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/d8918546-c0f5-4828-b0dc-2479fd6c482b)


内存碎片问题指的是空闲的内存无法被利用

*   外部碎片 : 分配单元间的未使用内存
*   内部碎片 : 分配单元内的未使用内存

### 分区的动态分配
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/1e991cac-e13f-4160-b880-b113437088ab)

何时分配连续的内存空间：
1.操作系统要把应用程序加载到内存中去，就需要分配一块连续的内存空间给应用程序，
2. 应用程序在运行时，需要访问数据，需要为数据分配一块内存空间，由操作系统完成，这片空间也需要是连续的
为此，操作系统管理整个空闲的和非空闲的内存空间，操作系统需要知道那些内存被占用和那些内存没有被占用，这是需要数据结构和算法来实现完成的。下面介绍三种。

分区的动态分配方式有以下三种 :

1.  第一匹配分配 : 在内存（物理内存）中找到第一个比需求大的空闲块, 分配给应用程序（内存回收（重分配）时，可以检查是否有相邻的空闲内存块可以合并）
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/3ebbb41c-00fa-4dc5-8a82-b4bbdef4db5e)
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/1ccd762a-1ef3-4278-93b4-aa72ae640984)


2.  最优适配分配 : 在内存（物理内存)中找到最小的空闲块, 分配给应用程序

![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/e8efb7ae-4ca8-4563-8317-d4c90e26ff07)
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/55605765-0829-4898-aebe-15f582eeefe6)


3.  最差适配分配 : 在内存（物理内存）中找到最大的空闲块, 分配给应用程序

![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/1bd01c94-4a18-446a-85d2-88615da91a46)
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/9c4d744f-e3e4-4e19-8ea7-f5e83557e2f3)




分配方式的区别

| 分配方式         | 第一匹配分配                                                 | 最优适配分配                                                 | 最差适配分配                                                 |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 分配方式实现需求 | 1. 按地址排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 | 1. 按尺寸排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 | 1. 按尺寸排序的空闲块列表<br />2. 分配最大的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区 |
| 优势             | 简单 / 易于产生更大空闲块                                    | 比较简单 / 大部分分配是小尺寸时高效                          | 分配很快 / 大部分分配是中尺寸时高效                          |
| 劣势             | 产生外部碎片 / 不确定性                                      | 产生外部碎片 / 重分配慢 / 产生很多没用的微小碎片             | 产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配 |

>   三种分配方式并无优劣之分，因为我们无法判断内存请求的大小

## 碎片整理方法

可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。

1.  压缩式碎片整理
    *   重置程序以合并孔洞
    *   要求所有程序是动态可重置的
    *   问题 : 
        *   何时重置 ? (在程序运行时不能挪动，在程序处于等待状态时才可以重置)
        *   需要考虑内存拷贝的开销
![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/9e8af8ad-50b6-40dc-914a-cabff03d2f63)


2.  交换式碎片整理
   ![image](https://github.com/renjiahui10/OperatingSystemInDepth/assets/114166264/bee2a18f-585a-418a-9a14-2bf1d7850ec8)


    *   运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存

    *   问题 :

        *   哪些程序应该被回收 ?

    *   情况 :

        运行中 : P3

        等待中 : P1 P2 P4

        内存分布 -> 主存 : OS / P1 / P3 / P2 / P4 磁盘 : 空

        当P3程序需要更大的内存时 ->

        内存分布 -> 主存 : OS / P1 / P3 / P2         磁盘 : P4



